#그래프를 표현하는 방법
● 인접 행렬
    그래프에 간선이 많이 존재하는 경우 사용
        (간선이 적으면 인접 노드리스트를 확인시간이 길어짐으로)
● 인접 리스트
    그래프에 간선이 적게 존재하는 경우 사용
        (간선이 많으면 간선 여부 확인시간이 길어짐으로)
(참고 : https://freestrokes.tistory.com/87 )

++++++++++++++++
메모리를 줄여보려고 data class Node를 사용하지 않고
같은레벨의 BFS가 끝나면 count를 올려주는 방식으로 구현도 해봤고,
반복문 안에 변수 할당 부분을 없애도 봤지만
메모리 사용량의 차이는 200KB정도로 미미한 수준이었다.
아래 ArrayDeque와 BufferedReader 사용유무에 있어서
메모리 사용량의 차이가 컸다.

코틀린의 ArrayDeque의 사용유무에 따라
메모리 사용량의 7000KB 정도 차이가 난다.
val Q = ArrayDeque<>() (+7000KB)
val Q = ArrayList<>() (+3000KB)
val Q :Queue<Int> = LinkedList() (+0KB)
(원래라면 LinkedList가 메모리 주소도 저장해야함으로 메모리가 더 커야하나
아마도 ArrayList가 저장공간을 확장하면서 사용되지 않는 미리 받아온 공간에
대한 메모리때문이지 않을까 싶다.)

(참고 :
- Array는 메모리상에 연속적으로 저장하고 Linked List는 비연속적으로 저장합니다. (메모리 구조의 차이)
   - Array는 데이터 접근이 빠르지만 공간을 미리 할당해야하기 때문에 메모리 낭비가 발생합니다.
   - Linked List는 사이즈를 필요한 만큼 늘리고 줄일 수 있기 때문에 메모리 낭비가 없습니다.
      단, 노드 address가 추가되기 때문에 메모리를 더 많이 사용합니다.)


BufferedReader를 사용했을 때가
Scanner(System.`in`)를 사용했을 때 보다
4000KB 더 많이 사용된다.
허나 입력량이 많다면 시간 초과를 방지하기 위해
BufferedReader를 사용하는게 더 적합하다고 생각된다.
비트마스킹이 아닌 그냥 구현으로 해당 문제를 해결하려고 했었다.
비트마스킹으로 BFS의 방향을 나타내는 방법이 힌트에 나와있었지만
비트마스킹이 뭔지 몰랐기에 그냥 하던대로 구현을 했다.

◆ 기존 구현 방법
각 좌표에 있는 번호를 when으로 분기문으로 8,4,2,1 숫자를 순서대로 0이 될때 까지
빼줌으로써 방향을 구하는 방식을 사용함 근데 이 과정에서 변수 할당과 리스트 생성이
비스마스킹 알고리즘을 사용하는 경우보다 잦아서, 메모리 초과가 나왔다. (답은 나옴)

◆ 해결 방법
비트마스킹을 사용하여
각 비트에 해당 숫자가 포함되어있는지 확인하는 방법으로 벽이 있는지 검사
for (z in 0 until 4){
    k = (1 shl z) // 1,2,4,8 //shl = 시프트 연산자
    if ((map[point.y][point.x] and k) != 0) continue // 벽 체크 (벽이 있으면 무시)
}

◆ 벽을 허무는 방법
map[i][j] = map[i][j] - k
해당 좌표값에 벽의 위치에 해당하는 수를 제거

◆ 추가로 느낀점
1. MY, MX 배열 방향을 정할때 그냥 기존에 짜두었던 코드를 복붙하는 방식으로 썼는데
    이런 문제처럼 검사하는 방향을 명시해주었다면 그 방향 순서로 정의해두는게 코드짜기 편하다.
2. 메모리 초과시 줄일 수 있는 포인트
    º List혹은 MutableList 정의를 Array로 바꿀 수 있다면 바꿔보자
    º 함수 혹은 main 함수 로직에서 변수 선언을 줄여보자.
    º 새로운 List 할당을 없애고, 기존의 List의 값을 바꾸는 방식으로 메모리를 아끼자 (초기화시 새로 선언하지말고 기존 List 다시 초기화)

